用户对象，进程拥有

窗口也是用户对象，但是线程拥有？

线程拥有意味着什么？意味着只有这个线程能够处理这个窗口的所有消息。

那线程为了处理所拥有窗口的所有消息需要做哪些工作呢？首先，它必须有一个消息队列，该消息队列用于分发窗口消息。然后线程还必须有自己的消息循环，消息循环用于冲消息队列中取出消息并交给窗口过程处理。


另外，一个拥有窗口的线程为了处理和窗口相关的东西，仅仅有消息队列还是不够的，每个线程还需要有一个模拟环境，以允许线程维护它自己的键盘焦点，窗口激活，鼠标捕获等操作。

那线程的消息队列和模拟环境具体体现是什么呢？是一个 THREADINFO 结构。在一个线程刚创建（即该没有创建任何窗口时），系统并不会给该线程分配一个 THREADINFO 结构，因为该线程还没有创建任何窗口，但只要该线程调用了一个图形用户界面函数（比如创建了一个窗口，或者检查了自己的消息队列），系统就会自动给线程分配这个结构。

THREADINFO 具体是什么样的？该结构并未公开，只能说该结构包含了如下信息:

* 投递消息队列
* 发送消息队列
* 应答消息队列
* 虚拟输入队列
* 唤醒标志
* 用来描述线程本地输入状态的若干变量

# 26.2 将消息投送到一个线程的消息队列中
这小节主要是告诉了我们什么是投递消息队列和投递消息队列相关相关的一些东西

# 26.3 向窗口发送消息
这小节一方面讲解了 SendMessage 内部的具体操作，另一方面也告诉了我们发送消息对了和应答消息队列的一些东西。

# 26.4 唤醒一个线程
从哪里唤醒？从线程的 GetMessage 或者 WaitMessage 调用中。

## 队列状态标志
表明特定消息队列中是否有消息。

### QS_SENDMESSAGE
系统内部使用该标志一确定和处理冲一个线程发送到另一个线程的消息。其实，这也是发送消息队列的意义，发送消息队列中不会存在拥有发送消息队列的线程调用 SendMessage 发送的消息，只会存在其他线程调用 SendMessage 发送给这个线程说拥有的窗口的消息。

## 26.4.2 从线程队列中提取消息的算法
具体来讲，就是当线程调用 GetMessage 或 PeekMessage 时，系统从消息队列中提取消息的步骤。

感觉比较有意思的一点是对发送消息队列中的消息的处理方式，GetMessage 和 PeekMessage 在内部将这些消息发送给适当的窗口过程，并且在窗口过程处理完消息后不返回给进程，而是等待其他要处理的消息。这和我们的一般认识不一样，通常我们会觉得消息都是由 DispatchMessage 分发给窗口过程的。

## 26.4.3 使用内核对象或者队列状态标识来唤醒一个线程
MsgWaitForMultipleObjects 和 MsgWaitForMultipleObjectsEx 感觉这两个函数还是比较冷门，使用上我觉得对我们并没有什么问题，但是关于这两个函数的使用情景实在想不出。

# 26.5 使用消息发送数据
这小节没什么说的，只不过又勾起了一些已经忘记的东西，比如内存映射文件 。

# 26.6 Windows 处理 ANSI/Unicode 字符和字符串的方法
同样，又是一些已经忘记的东西，如窗口类。原来决定一个窗口是 ANSI 窗口还是 Unicode 窗口，取决于注册窗口类时使用的是 RegisterClassA，还是 RegisterClassW。其实这也是使用多字节字符集 MFC 程序和使用 Unicode 字符集的 MFC 程序之间的本质区别。
使用多字节字符集的 MFC 程序的窗口是 ANSI 窗口，窗口的窗口类采用 RegisterClassA 注册；使用 Unicode 字符集的 MFC 程序的窗口是 Unicode 窗口，窗口的窗口类使用 RegisterClassW 注册。

# 第 27 章 硬件输入模型与本地输入状态
微软引入输入模型的主要目标是确保一个线程的动作不能对其他线程的动作产生负面影响。下面就是这方面的一个负面的例子：在 16 位 Windows 中，如果一个任务进入到一个无线循环中，则所有的任务都将挂起，并且不在响应用户，用户不得不重启计算机。

## 27.1 原始输入线程
原始输入线程 raw input thread
系统硬件输入队列 system hardware input queue
硬件输入消息包括鼠标消息和键盘消息

怎样再能知道将硬件输入消息追加到哪个现成的虚拟输入队列呢？
这个过程并不难理解。

需要注意如下点：
RIT 负责处理特殊的按键序列，例如 Alt + Tab、Alt + Esc 和 Ctrl + Alt + Del。RIT 在内部处理这些按键序列，就可以确保用户总能使用键盘来激活窗口。

## 27.2 本地输入状态
本地输入状态保存在线程的 THREADINFO 结构中。本地输入状态由线程的虚拟输入队列和一组变量构成。这些变量用来跟踪下面的输入状态管理信息：

* 键盘输入以及窗口焦点信息，例如：
    - 哪个窗口有键盘焦点
    - 哪个窗口是激活的
    - 哪个键被认为是按下的
    - 插入符号的状态
* 鼠标光标的管理信息，例如：
    - 哪个窗口具有鼠标捕获
    - 鼠标光标的形状
    - 鼠标光标的可见

这些状态确实是需要每个线程单独维护的状态。
### 27.2.1 键盘输入和焦点
键盘焦点存在的意义就在于告诉线程将虚拟输入队列中的键盘事件分发给线程的那个窗口。

### 27.2.2 鼠标光标管理
#### 光标的隐藏/显示能力
#### 使用 ClipCursor 函数将光标剪贴到屏幕上一个矩形区域的功能
#### 鼠标捕获
鼠标捕获感觉书上没有写清楚，不过弄了例子，试下肯定就没问题了。
#### 鼠标光标的形状

## 27.3 将虚拟输入队列和本地输入状态相关联
这小节就讨论了这个问题，让两个或者多个线程共享一组单独的本地输入状态变量以及一个单独的虚拟输入队列。